<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b>roslua: ROS client library for Lua</b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>roslua</h1>

<ul>
	
	<li><a href="../index.html">Index</a></li>
	
</ul>


<!-- Module list -->

<h1>Modules</h1>
<ul>

	<li>
		<a href="../modules/roslua.html">roslua</a>
	</li>

	<li>
		<a href="../modules/roslua.logging.html">roslua.logging</a>
	</li>

	<li>
		<a href="../modules/roslua.master_proxy.html">roslua.master_proxy</a>
	</li>

	<li>
		<a href="../modules/roslua.message.html">roslua.message</a>
	</li>

	<li>
		<a href="../modules/roslua.msg_spec.html">roslua.msg_spec</a>
	</li>

	<li>
		<a href="../modules/roslua.param_proxy.html">roslua.param_proxy</a>
	</li>

	<li>
		<a href="../modules/roslua.publisher.html">roslua.publisher</a>
	</li>

	<li>
		<a href="../modules/roslua.registry.html">roslua.registry</a>
	</li>

	<li>
		<a href="../modules/roslua.service.html">roslua.service</a>
	</li>

	<li><strong>roslua.service_client</strong></li>
	
	<li>
		<a href="../modules/roslua.slave_api.html">roslua.slave_api</a>
	</li>

	<li>
		<a href="../modules/roslua.slave_proxy.html">roslua.slave_proxy</a>
	</li>

	<li>
		<a href="../modules/roslua.srv_spec.html">roslua.srv_spec</a>
	</li>

	<li>
		<a href="../modules/roslua.subscriber.html">roslua.subscriber</a>
	</li>

	<li>
		<a href="../modules/roslua.tcpros.html">roslua.tcpros</a>
	</li>

	<li>
		<a href="../modules/roslua.time.html">roslua.time</a>
	</li>

	<li>
		<a href="../modules/roslua.timer.html">roslua.timer</a>
	</li>

	<li>
		<a href="../modules/roslua.utils.html">roslua.utils</a>
	</li>

</ul>



<!-- File list -->






</div><!-- id="navigation" -->

<div id="content">

<h1>Module <code>roslua.service_client</code></h1>

<p>Service client. This module contains the ServiceClient class to access services provided by other ROS nodes. It is created using the function <code>roslua.service_client()</code>. <br /><br /> The service client employs the <code>__call()</code> meta method, such that the service can be called just as <code>service_client(...)</code>. As arguments you must pass the exact number of fields required for the request message in the exact order and of the proper type as they are defined in the service description file.</p>


<p>Copyright&copy; Tim Niemueller, Carnegie Mellon University, Intel Research Pittsburgh</p>


<p><small><b>Release:</b> Released under BSD license</small></p>



<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:concexec_abort">ServiceClient:concexec_abort</a>&nbsp;()</td>
	<td class="summary">Abort the execution.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:concexec_failed">ServiceClient:concexec_failed</a>&nbsp;()</td>
	<td class="summary">Check if execution has failed.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:concexec_finished">ServiceClient:concexec_finished</a>&nbsp;()</td>
	<td class="summary">Check if execution has failed or succeeded </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:concexec_result">ServiceClient:concexec_result</a>&nbsp;()</td>
	<td class="summary">Get execution result.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:concexec_start">ServiceClient:concexec_start</a>&nbsp;(args)</td>
	<td class="summary">Initiate service execution.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:concexec_succeeded">ServiceClient:concexec_succeeded</a>&nbsp;()</td>
	<td class="summary">Check if execution is finished successfully.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:concexec_wait">ServiceClient:concexec_wait</a>&nbsp;()</td>
	<td class="summary">Wait for the execution to finish.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:connect">ServiceClient:connect</a>&nbsp;()</td>
	<td class="summary">Connect to service provider.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:execute">ServiceClient:execute</a>&nbsp;(args)</td>
	<td class="summary">Execute service.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:finalize">ServiceClient:finalize</a>&nbsp;()</td>
	<td class="summary">Finalize instance.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#ServiceClient:new">ServiceClient:new</a>&nbsp;(args_or_service, srvtype)</td>
	<td class="summary">Constructor.</td>
	</tr>

</table>






<br/>
<br/>



<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="ServiceClient:concexec_abort"></a><strong>ServiceClient:concexec_abort</strong>&nbsp;()</dt>
<dd>
Abort the execution. Note that this does not actually stop the execution on the server side, rather we just close the connection as to not receive the result. The connection will be closed even if it is marked persistent. It will be reopened on the next call.









</dd>




<dt><a name="ServiceClient:concexec_failed"></a><strong>ServiceClient:concexec_failed</strong>&nbsp;()</dt>
<dd>
Check if execution has failed. Precondition is that the service is being concurrently executed.







<h3>Return value:</h3>
true if the execution is finished and a result has been received, false otherwise



</dd>




<dt><a name="ServiceClient:concexec_finished"></a><strong>ServiceClient:concexec_finished</strong>&nbsp;()</dt>
<dd>
Check if execution has failed or succeeded







<h3>Return value:</h3>
true if the execution is finished, false otherwise



</dd>




<dt><a name="ServiceClient:concexec_result"></a><strong>ServiceClient:concexec_result</strong>&nbsp;()</dt>
<dd>
Get execution result. Precondition is that the service is being concurrently executed and has finished.







<h3>Return value:</h3>
service return value



</dd>




<dt><a name="ServiceClient:concexec_start"></a><strong>ServiceClient:concexec_start</strong>&nbsp;(args)</dt>
<dd>
Initiate service execution. This starts the execution of the service in a way it can be handled concurrently. The request will be sent, afterwards the concexec_finished(), concexec_result(), and concexec_wait() methods can be used.


<h3>Parameters</h3>
<ul>
	
	<li>
	  args: argument array
	</li>
	
</ul>








</dd>




<dt><a name="ServiceClient:concexec_succeeded"></a><strong>ServiceClient:concexec_succeeded</strong>&nbsp;()</dt>
<dd>
Check if execution is finished successfully. Precondition is that the service is being concurrently executed.







<h3>Return value:</h3>
true if the execution is finished and a result has been received, false otherwise



</dd>




<dt><a name="ServiceClient:concexec_wait"></a><strong>ServiceClient:concexec_wait</strong>&nbsp;()</dt>
<dd>
Wait for the execution to finish.









</dd>




<dt><a name="ServiceClient:connect"></a><strong>ServiceClient:connect</strong>&nbsp;()</dt>
<dd>
Connect to service provider.









</dd>




<dt><a name="ServiceClient:execute"></a><strong>ServiceClient:execute</strong>&nbsp;(args)</dt>
<dd>
Execute service. This method is set as __call entry in the meta table. See the module documentation on the passed arguments. The method will return only after it has received a reply from the service provider!


<h3>Parameters</h3>
<ul>
	
	<li>
	  args: argument array
	</li>
	
</ul>








</dd>




<dt><a name="ServiceClient:finalize"></a><strong>ServiceClient:finalize</strong>&nbsp;()</dt>
<dd>
Finalize instance.









</dd>




<dt><a name="ServiceClient:new"></a><strong>ServiceClient:new</strong>&nbsp;(args_or_service, srvtype)</dt>
<dd>
Constructor. The constructor can be called in two ways, either with positional or named arguments. The latter form allows to set additional parameters. In the positional form the ctor takes two arguments, the name and the type of the service. For named parameters the parameter names are service (for the name), type (service type) and persistent. If the latter is set to true the connection to the service provider ROS node will not be closed after one service call. This is beneficial when issuing many service calls in a row, but no guarantee is made that the connection is re-opened if it fails.<br /><br /> Examples:<br /> Positional: <code>ServiceClient:new("/myservice", "myservice/MyType")</code> Named: <code>ServiceClient:new{service="/myservice", type="myservice/MyType",persistent=true}</code> (mind the curly braces instead of round brackets!)


<h3>Parameters</h3>
<ul>
	
	<li>
	  args_or_service: argument table or service name, see above
	</li>
	
	<li>
	  srvtype: service type, only used in positional case
	</li>
	
</ul>








</dd>


</dl>






</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->	
</body>
</html>
